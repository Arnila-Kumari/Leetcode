{
  "problem_name": "house-robber",
  "data_structures": [
    [
      "variables for dynamic programming states"
    ]
  ],
  "category": "1-D Dynamic Programming",
  "algorithm_technique": [
    "Dynamic programming with O(1) space by tracking previous two states."
  ],
  "problem_summary_simple": "Rob houses to maximize money without robbing adjacent ones.",
  "problem_summary_technical": "Apply DP: max(rob current + prev_prev, skip current) to find max loot.",
  "time_complexity": [
    "O(n)"
  ],
  "space_complexity": [
    "O(1)"
  ],
  "key_insights": [
    [
      "This is a classic DP problem where the decision at each house depends on previous decisions.",
      "The space complexity can be optimized to O(1) by only storing the results of the two preceding houses.",
      "The recurrence relation is `dp[i] = max(nums[i] + dp[i-2], dp[i-1])`."
    ]
  ],
  "difficulty_level": "Easy",
  "analysis_timestamp": "2025-07-16 21:47:01",
  "batch_processed": true,
  "batch_size": 5
}